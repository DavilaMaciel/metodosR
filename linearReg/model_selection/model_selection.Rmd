---
title       : "Seleção de Modelos"
subtitle    : "Análise de dados com modelos lineares em R"
author      : "Nicholas A. C. Marino"
job         : "Universidade Federal do Rio de Janeiro"
date        : "github.com/nacmarino/metodosR"
output:
  html_document:
    widescreen: true
    smaller: true
---

## Seleção de Modelos  

* É o processo pelo qual vamos determinar qual é o modelo que melhor se adequa ao conjunto de dados que possuímos.  
* Princípio da parcimônia - menos é mais.  

<center><img src="figures/phd101209s.gif" height="350px"></img></center>  

## Antes de começar  

Alguns pacotes úteis.

```{r eval=FALSE}
install.packages("fitdistrplus") # funções para avaliar e descrever distribuição dos dados
install.packages("AICcmodavg") # uma opção para seleção de modelos
install.packages("MuMin") # outra opção para seleção de modelos
install.packages("car") # conjunto de funções úteis para regressão
install.packages("lmerTest") # funções especialmente úteis para lmer
install.packages("lsmeans") # funções para pós-teste
install.packages("multcomp") # outra opção para pós-teste
install.packages("broom") # funcionalidades para trabalhar com os resultados
install.packages("visreg") # para visualizar o resultado dos seus modelos
```

## Antes de começar  

Vamos carregar um conjunto de dados para trabalharmos.

```{r}
ilhas <- read.table(file = "dados/ilhas.txt", header = TRUE)
```

```{r}
str(ilhas)
```

## Passo 1 | Saber o que queremos fazer

* A relação espécie-área (Arrhenius, 1921, J Ecol 9: 95-99) é uma das relações mais conhecidas e exploradas da ecologia;  
  
* O estudo de Biogeografia de Ilhas, por MacArthur & Wilson (1967), foi uma grande contribuição para entendermos a dinâmica ecológica nestes habitats;  
  
* Podemos usar essas informações como um ponto de partida para direcionar nossas análises:  
  
      1. A riqueza de espécies em uma ilha aumenta como a sua área (log-log).    
      2. A riqueza de espécies em uma ilha aumenta com a quantidade de energia disponível.  
      3. A riqueza de espécies em uma ilha aumenta com a diversidade de habitats.  
      4. Ilhas oceânicas possuem menor riqueza de espécies do que ilhas costeiras de mesmo tamanho.
      5. Ilhas em arquipelagos maiores devem ter mais espécies que em arquipelagos menores.  

## Passo 2 | Visualizar os dados e relação entre eles

* Etapa conhecida como análise exploratória de dados.  
* Um jeito rápido (e "sujo") de fazer isso é com a função `pairs`;    
* Mas também podemos usar o `ggplot2`!  

## Passo 2 | Visualizar os dados e relação entre eles

```{r fig.align='center', fig.width=4, fig.height=4}
library(ggplot2)
qplot(x = area, y = riqueza, data = ilhas, log = "xy", xlab = "Área da Ilha (log)",
      ylab = "Riqueza de Espécies (log)")
```

## Passo 2 | Visualizar os dados e relação entre eles

Quando estamos explorando graficamente os dados é importante plotarmos a maior quantidade de informações possíveis em uma mesma figura, para nos ajudar a:  
  
      - Visualizar o tipo de relação existente entre as variáveis (positiva, negativa,...)  
      
      - Visualizar a forma da relação entre as variáveis (linear, unimodal,...)  
      
      - Saber que podemos testar de fato ("temos todos os níveis em todas as categorias?")  
      
      - Determinar se existe algum tipo de interação que deve ser considerada  

## Passo 2 | Visualizar os dados e relação entre eles

```{r fig.align='center', fig.width=8, fig.height=4}
qplot(x = area, y = riqueza, data = ilhas, log = "xy", facets = ~ arquipelago,
      xlab = "Área da Ilha (log)", ylab = "Riqueza de Espécies (log)")
```

## Passo 2 | Visualizar os dados e relação entre eles

```{r fig.align='center', fig.width=8, fig.height=4}
qplot(x = area, y = riqueza, data = ilhas, log = "xy", facets = ~ arquipelago,
      colour = ilha, xlab = "Área da Ilha (log)", ylab = "Riqueza de Espécies (log)")
```

## Passo 2 | Visualizar os dados e relação entre eles

```{r fig.align='center', fig.width=8, fig.height=4}
qplot(x = area, y = riqueza, data = ilhas, log = "xy", facets = ~ arquipelago,
      colour = ilha, size = log10(produtividade), xlab = "Área da Ilha (log)", 
      ylab = "Riqueza de Espécies (log)")
```

## Passo 2 | Visualizar os dados e relação entre eles

```{r fig.align='center', fig.width=8, fig.height=4}
qplot(x = area, y = riqueza, data = ilhas, log = "xy", facets = ~ arquipelago,
      colour = ilha, size = log10(produtividade), xlab = "Área da Ilha (log)", 
      shape = montanha, ylab = "Riqueza de Espécies (log)")
```

## Passo 2 | Visualizar os dados e relação entre eles

* Conclusões da análise exploratório dos gráficos:  
    + Parece que todos os dados estão OK e não tem nenhum outlier;  
    + A relação log-log entre riqueza e área parece se adequar melhor;  
    + Tem várias coisas rolando: produtividade, tipo de ilha, tamanho do arquipelago...
    + Devemos capturar essas características com os nossos modelos.

## Passo 3 | Descobrir a distibuição da variável resposta  

**Opção 1**: Teste de Shapiro-Wilk.

```{r}
shapiro.test(ilhas$riqueza);shapiro.test(log10(ilhas$riqueza))
```

## Passo 3 | Descobrir a distibuição da variável resposta  

**Opção 2**: histograma.

```{r eval=FALSE}
qplot(x = riqueza, data = ilhas, geom = "histogram", xlab = "Riqueza de Espécies", ylab = "Observações")
qplot(x = log10(riqueza), data = ilhas, geom = "histogram", xlab = "Riqueza de Espécies (log10)")
```

```{r echo=FALSE, message=FALSE, warning=FALSE, fig.align='center', fig.height=3, fig.width=5}
library(gridExtra)
grid.arrange(qplot(x = riqueza, data = ilhas, geom = "histogram", xlab = "Riqueza de Espécies", ylab = "Observações"), qplot(x = log10(riqueza), data = ilhas, geom = "histogram", xlab = "Riqueza de Espécies (log10)", ylab = ""), nrow = 1)
```

## Passo 3 | Descobrir a distibuição da variável resposta  

**Opção 3**: Q-Q Plot.

```{r fig.align='center', fig.height=4, fig.width=6}
par(mfrow = c(1,2))
qqnorm(ilhas$riqueza);qqline(ilhas$riqueza)
qqnorm(log10(ilhas$riqueza));qqline(log10(ilhas$riqueza))
```

## Passo 3 | Descobrir a distibuição da variável resposta  

**Opção 4**: Gráfico de Cullen e Frey.
```{r fig.align='center', fig.height=4, fig.width=6, warning=FALSE, message=FALSE}
library(fitdistrplus)
descdist(ilhas$riqueza, boot = 1000)
```

## Passo 3 | Descobrir a distibuição da variável resposta  

**Opção 4**: Gráfico de Cullen e Frey.
```{r fig.align='center', fig.height=4, fig.width=6, warning=FALSE, message=FALSE}
descdist(log10(ilhas$riqueza), boot = 1000)
```

## Observação  

O que é _kurtosis_ e _skewness_?

<center><img src="figures/kurtosis.png" height="260px"></img></center>  

## Passo 4 | Estabelecer um modelo nulo  

* O que é um modelo nulo?
    + Também conhecido como modelo reduzido.  
    + É o modelo base, que diz que não existe nenhuma relação entre sua variável resposta e as preditoras;  
    + Este modelo normalmente contém somente o intercepto (_y_ = $\beta$~0~);  
    + Ele também pode conter características especiais do seu desenho (fator aleatório, medidas repetidas)...  
    
## Passo 4 | Estabelecer um modelo nulo  

```{r}
modelo_nulo <- glm(log10(riqueza) ~ 1, data = ilhas, family = gaussian(link = "identity"))
summary(modelo_nulo)
```

## Passo 4 | Estabelecer um modelo nulo  

* Mas...o que é o intercepto?  
* Rode isso no seu console:

```{r eval=FALSE}
medify <- function(mu, x){
  hist(x, col="red", breaks = 10, main = "Histograma Exploratório",
       xlab = "Riqueza de Espécies (log)")
  lines(c(mu, mu), c(0, 25), col="black", lwd=5)
  mse <- mean((x - mu)^2)
  text(0.8, 20, paste("mu = ", round(mu, 2)))
  text(0.8, 18, paste("MSE = ", round(mse, 2)))
}

library(manipulate)
manipulate(medify(mu, log10(ilhas$riqueza)), mu = slider(0, 2, step = 0.05));rug(log10(ilhas$riqueza))
```

## Passo 4 | Estabelecer um modelo nulo  

* Então, um modelo somente com intercepto seria simplesmente o valor _médio_ daquela variável resposta.    

```{r}
summary(modelo_nulo)$coef
mean(log10(ilhas$riqueza))
```

## Observação  

* Usar a função `glm` com a distribuição `family = gaussian` e a função de relação com a média `link = "identity"` gera o mesmo resultado da função `lm`.  

```{r}
ex1 <- lm(log10(riqueza) ~ 1, data = ilhas)
summary(ex1)$coef
ex2 <- glm(log10(riqueza) ~ 1, data = ilhas, family = gaussian(link = "identity"))
summary(ex2)$coef
```

## Passo 5 | Criar um modelo  

Vamos criar um modelo, relacionando o logaritmo da riqueza de espécies com o da área da ilha.  
```{r}
modelo1 <- glm(log10(riqueza) ~ log10(area), data = ilhas)
summary(modelo1)
```

## Passo 6 | Comparar com o modelo nulo  

**Opção 1**: função `anova` + outras funções.

```{r}
anova(modelo_nulo, modelo1, test = "F")
AIC(modelo_nulo, modelo1) # BIC(modelo_nulo, modelo1)
```

## Passo 6 | Comparar com o modelo nulo  

**Opção 2**: função `AICcmodavg::aictab`.
```{r warning=FALSE, message=FALSE}
library(AICcmodavg)
modelos <- list(modelo_nulo, modelo1)
aictab(cand.set = modelos, modnames = c("nulo", "com area"))
```

## Passo 6 | Comparar com o modelo nulo  

**Opção 3**: função `MuMin::model.sel`.
```{r warning=FALSE, message=FALSE}
library(MuMIn)
model.sel(modelo_nulo, modelo1)
```

## Até agora...  

* Podemos concluir que o modelo com a adição de um termo para a área ($\beta$~1~) melhora o ajuste do modelo aos dados;  
* Mas lembrando da análise exploratória de dados, rolava alguma coisa com...  
    + Tipo de ilha: costeira vs oceanica
    + Tamanho do arquipelago: pequeno vs medio vs grande  
    + Montanha: presença vs ausência
    + Produtividade  
    + Diversidade de Habitats e outros
* Vamos criar modelos incluindo estas variáveis.

## Passo 7 | Adicionar/remover variáveis do modelo  

* Antes de fazer o trabalho criativo da criação de modelos, vamos abordar um exemplo com a inclusão de uma variável categórica no modelo.  
```{r}
modelo2 <- glm(log10(riqueza) ~ arquipelago, data = ilhas)
summary(modelo2)
```

## Passo 7 | Adicionar/remover variáveis do modelo  

* Onde está os dados referente ao arquipélago grande?  
* Que valores de significância são esses?   

```{r echo=FALSE}
knitr::kable(summary(modelo2)$coef, format = "html", digits = c(3, 3, 3, 4), align = "c")
```

## Passo 7 | Adicionar/remover variáveis do modelo 

Como o R trabalha com os seus fatores?  

```{r}
head(model.matrix(~ilhas$arquipelago))
```

## Passo 7 | Adicionar/remover variáveis do modelo  

* Por padrão, sempre que existir uma variável categórica no modelo, o R vai usar um dos níveis para ser o valor de $\beta$~0~ (o intercepto), e o valor dos parâmetros dos demais níveis serão estimados relativo ao $\beta$~0~.  
  
* Por padrão, o R seleciona o nível cujo nome vier primeiro no alfabeto.  
  
* Uma forma de ver esse modelo:

<center>_y_ = $\beta$~grande~ + $\beta$~médio~ * X~log(S)~ + $\beta$~pequeno~ * X~log(S)~</center>

## Passo 7 | Adicionar/remover variáveis do modelo  

* Você pode remover o intercepto do modelo.
```{r eval=FALSE}
ex3 <- glm(log10(riqueza) ~ 0 + arquipelago, data = ilhas)
summary(ex3)
```

```{r echo=FALSE}
ex3 <- glm(log10(riqueza) ~ 0 + arquipelago, data = ilhas)
knitr::kable(summary(ex3)$coef, format = "html", digits = c(3, 3, 3, 4), align = "c")
```

## Passo 7 | Adicionar/remover variáveis do modelo  

* Ou selecionar que nível o R vai usar como intercepto.  
```{r eval=FALSE}
ex4 <- glm(log10(riqueza) ~ I(1 * (arquipelago == "grande")) +
                 I(1 * (arquipelago == "medio")), data = ilhas)
summary(ex4)
```

```{r echo=FALSE}
ex4 <- glm(log10(riqueza) ~ I(1 * (arquipelago == "grande")) +
                 I(1 * (arquipelago == "medio")), data = ilhas)
knitr::kable(summary(ex4)$coef, format = "html", digits = c(3, 3, 3, 4), align = "c")
```

## Passo 7 | Adicionar/remover variáveis do modelo  

* Você também pode alterar este padrão redefinindo os níveis dos contrastes no R.
```{r}
contrasts(ilhas$arquipelago)
```

```{r evan=FALSE}
contrasts(ilhas$arquipelago) <- cbind(grande = c(1,0,0), medio = c(0,1,0))
```

## Observações  

* O que significa o estimate com ou sem o intercepto?

```{r echo = FALSE, warning=FALSE, message=FALSE}
library(dplyr)
knitr::kable(ilhas %>% group_by(arquipelago) %>% summarise(media = mean(log10(riqueza))) %>% mutate(diferenca = c(0, diff(media))),
             format = "html", align = "c")
```
  
```{r}
knitr::kable(summary(ex3)$coef[,1:2], format = "html", digits = c(3, 3, 3, 4), align = "c")
knitr::kable(summary(modelo2)$coef[,1:2], format = "html", digits = c(3, 3, 3, 4), align = "c")
```

## Observações  

* O que significa o estimate com ou sem o intercepto?
    + Quando temos o intercepto, os valores dos coeficientes no `summary` são a diferença entre as médias o nível que representa o intercepto e o outro.  
    + Quando removemos o intercepto, os valores dos coeficientes no `summary` são as médias de cada tratamento.  
  
* Remover ou não o intercepto?  
    + A não ser que você possua alguma hipótese específica, a sugestão é sempre manter o intercepto do modelo como está.  
  
* Você deve usar essas diferenças como estimativa de significância?  
    + Sim, se você tiver alguma hipótese específica cujo output do `summary` responda;  
    + Não, se você possui múltiplas comparações entre níveis de variáveis ou quer fazer pós-testes mais complexos.  

## Passo 7 | Adicionar/remover variáveis do modelo  

De volta à criação de modelos.  
```{r}
modelo3 <- glm(log10(riqueza) ~ log10(area) * arquipelago, data = ilhas)
modelo4 <- glm(log10(riqueza) ~ log10(area) + arquipelago, data = ilhas)
modelo5 <- glm(log10(riqueza) ~ log10(area) * ilha, data = ilhas)
modelo6 <- glm(log10(riqueza) ~ log10(area) + ilha, data = ilhas)
modelo7 <- glm(log10(riqueza) ~ log10(area) + ilha + arquipelago, data = ilhas)
modelo8 <- glm(log10(riqueza) ~ log10(area) + ilha + arquipelago + log10(produtividade), data = ilhas)
modelo9 <- glm(log10(riqueza) ~ log10(area) + ilha + arquipelago + temperatura, data = ilhas)
```

## Passo 8 | Comparar os novo(s) modelo(s)  

* Vamos comparar os modelos criados com o `AICcmodavg::aictab`.  
```{r eval=FALSE}
modelos <- list(modelo_nulo, modelo1, modelo2, modelo3, modelo4, modelo5, modelo6, modelo7, modelo8, modelo9)
mod_names <- c("nulo", "com area", "arquipelago", "area*arq", "area+arq", "area*ilha", "area+ilha", 
               "area+ilha+arq", "area+ilha+arq+produt", "area+ilha+arq+temp")
aictab(modelos, mod_names)
```

```{r echo=FALSE}
modelos <- list(modelo_nulo, modelo1, modelo2, modelo3, modelo4, modelo5, modelo6, modelo7, modelo8, modelo9)
mod_names <- c("nulo", "com area", "arquipelago", "area*arq", "area+arq", "area*ilha", "area+ilha", 
               "area+ilha+arq", "area+ilha+arq+produt", "area+ilha+arq+temp")
knitr::kable(aictab(modelos, mod_names), format = "html", align = "c", digits = 2)
```

## Passo 8 | Comparar os novo(s) modelo(s)  

* Também podemos comparar os modelos criados com o `MuMIn::model.sel`.  

```{r eval=FALSE}
model.sel(modelo_nulo, modelo1, modelo2, modelo3, modelo4, modelo5, modelo6, modelo7, modelo8, modelo9)
```

```{r echo=FALSE}
knitr::kable(data.frame(model.sel(modelo_nulo, modelo1, modelo2, modelo3, modelo4, 
                       modelo5, modelo6, modelo7, modelo8, modelo9))[,-c(1:8)], digits = 2, format = "html")
```

## Passo 9 | Determinar o modelo mais provável  

* Por vezes, você pode ter modelos cujo suporte sejam muito similares e você precisa decidir entre um deles.  
* Existem várias formas de você fazer isso, mas, no contexto do que estamos trabalhando, podemos continuar utilizando as ferramentas da seleção de modelos para chegarmos ao modelo mais provável.  
* A função `stats::drop1` te mostra o quanto mudaria o valor de AIC caso você deletasse cada um dos termos no modelo.  

## Passo 9 | Determinar o modelo mais provável  

Por exemplo, rode cada uma dessas linhas e veja que sempre que a área e o tipo de ilha, além do tamanho do arquipélago, são deletados do modelo, o valor de AIC aumenta, ao invés de cair.  

```{r eval=FALSE}
drop1(modelo7)
drop1(modelo9)
drop1(modelo8)
```

## Passo 9 | Determinar o modelo mais provável  

* A seleção de modelos, e o nosso julgamento, sugerem que os modelos com a área da ilha (log10), o tipo de ilha (costeira vs oceanica) e o tamanho do arquipelago (pequeno vs medio vs grande) são variáveis muito importantes para descrever a riqueza de espécies (log10) neste conjunto de dados.  
    + Os melhores modelos contém estas variáveis ou combinações delas;  
    + A remoção de qualquer uma destas variáveis tem um impacto muito maior nos valores de AIC (e demais métricas) do que a remoção das outras variáveis;  
    + Por parcimônia, devemos escolher o modelo mais simples.  
* O modelo 7 tem bastante suporte para ser o modelo de trabalho.  

## Considerações finais

* Ao invés de construir modelos a partir do zero, você também pode criar um modelo completo e usar algumas funções para tentar "enxugar" ele.
* A função `MuMIn::dredge` pode fazer isso, além da função `stats::step` (para `lm` e `glm`).  

```{r}
modelo_completo <- glm(log10(riqueza) ~ log10(area) + ilha + arquipelago + temperatura + precipitacao +
                         log10(produtividade) + habitat + montanha + populacao, data = ilhas)
```

```{r eval=FALSE}
step(modelo_completo)
dredge(modelo_completo) # você deve usar <options(na.action = "na.fail")> antes de rodar essa função
```

## Considerações finais  

* No entanto, essa não é uma boa prática para a análise de dados:
    + Parece que você está tentando "pescar" um resultado.    
    + Você **tem** uma hipótese de trabalho.  
    + Modelos construídos desta maneira podem não fazer sentido. 
    + Complexidade destes modelos pode (e possivelmente) ser alta demais.  
    + Modelos selecionados podem ser modelos "problemáticos" (vamos ver isso nas próximas aulas).  

## Considerações finais  

1. Tenha sempre em mente a hipótese que você quer responder;  
2. Tente entender seus dados antes de você começar a analisá-los;  
3. A seleção de modelos pode ser uma ferramenta muito útil para separar o joio do trigo;  
4. Tenha em mente que a seleção de modelos por si só não te indica qual modelo é o mais adequado - você precisa saber se o modelo selecionado é válido também (tema da próxima aula).